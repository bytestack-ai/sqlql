# sqlql
A GraphQL-like DSL and codegen toolchain for typed SQL queries

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)

## Overview

sqlql is a modern toolchain for working with SQL in a type-safe manner. It provides a GraphQL-inspired interface for defining SQL queries with strong typing, enabling developers to write safer database code with excellent IDE support.

## Features

- **Plugin-based Code Generation**: Generate type-safe database clients in multiple languages
  - First-party support for Python and TypeScript
  - Extensible architecture for additional language support

- **Dialect Support**: Work with different SQL dialects through a plugin system
  - Write once, deploy to any supported database
  - Centralized database definitions with type, version, and plugin information

- **Rich IDE Integration**: Enhanced developer experience with
  - VSCode extension
  - Windsurf integration
  - Cursor support
  - Syntax highlighting, autocompletion, and type checking

- **Parameterized Interface**: Type-safe variable templating for SQL queries
  - Prevent SQL injection by design
  - Validate parameter types at compile time
  - Target specific databases with `@database` directive

- **High Performance**: Built with Rust for
  - Fast compilation and code generation
  - Memory safety without sacrificing speed
  - Cross-platform support

## Current Status

sqlql is currently in active development. Our team is focused on:

- Developing the core type interface
- Implementing the plugin architecture
- Building language-specific code generators

## Installation

*Coming soon*

## Quick Start

*Coming soon*

## Example

### Database Definition

```typescript
// Define your databases centrally
const databases = {
  production: {
    type: "postgres",
    version: "14.5",
    plugins: ["pgvector", "timescaledb"]
  },
  analytics: {
    type: "clickhouse",
    version: "22.8.1",
    plugins: []
  }
};
```

### Query Definition

```sql
-- Define a query with typed parameters and target database
query getUserPosts($userId: UUID, $limit: Int = 10) @database(production) {
  SELECT p.id, p.title, p.content, u.username
  FROM posts p
  JOIN users u ON p.user_id = u.id
  WHERE p.user_id = $userId
  LIMIT $limit
}

-- A query targeting a different database
query getUserAnalytics($userId: UUID, $days: Int = 30) @database(analytics) {
  SELECT
    toDate(timestamp) as date,
    count() as visit_count
  FROM user_events
  WHERE user_id = $userId
    AND timestamp >= now() - interval $days day
  GROUP BY date
  ORDER BY date DESC
}
```

Generated TypeScript:

```typescript
// Auto-generated by sqlql - do not modify directly

// Database client types based on central definitions
export interface PostgresClient {
  type: "postgres";
  version: string;
  plugins: string[];
  // Connection details and methods
}

export interface ClickhouseClient {
  type: "clickhouse";
  version: string;
  plugins: string[];
  // Connection details and methods
}

export type DatabaseClient = PostgresClient | ClickhouseClient;

// Database registry with typed clients
export const databases = {
  production: {} as PostgresClient,
  analytics: {} as ClickhouseClient
};

// Generated types for the first query
export interface GetUserPostsParams {
  userId: string; // UUID
  limit?: number; // defaults to 10
}

export interface GetUserPostsResult {
  id: string;
  title: string;
  content: string;
  username: string;
}

// The function is now aware of which database to use
export async function getUserPosts(
  params: GetUserPostsParams
): Promise<GetUserPostsResult[]> {
  // Implementation uses the production database defined in the query
  const client = databases.production;
  // Type-safe implementation details handled by the code generator
  // Client is guaranteed to be PostgresClient type
}

// Generated types for the second query
export interface GetUserAnalyticsParams {
  userId: string; // UUID
  days?: number; // defaults to 30
}

export interface GetUserAnalyticsResult {
  date: string;
  visit_count: number;
}

export async function getUserAnalytics(
  params: GetUserAnalyticsParams
): Promise<GetUserAnalyticsResult[]> {
  // Implementation uses the analytics database defined in the query
  const client = databases.analytics;
  // Type-safe implementation details handled by the code generator
  // Client is guaranteed to be ClickhouseClient type
}
```

## Architecture

sqlql consists of several components:

1. **Core Parser**: Processes sqlql syntax and builds an AST
2. **Type System**: Validates query structure and parameter usage
3. **Database Registry**: Centralized configuration of database connections with metadata
4. **Plugin System**: Extensible architecture for languages and dialects
5. **Code Generators**: Create type-safe clients in target languages
6. **IDE Extensions**: Provide developer tooling and assistance

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT

## About ByteStack

sqlql is developed by [ByteStack](https://bytestack.ai), creators of developer tools focused on improving productivity and code quality.
